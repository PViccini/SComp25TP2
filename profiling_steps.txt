%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% PROFILING CON PYHTON
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Para ejecutar correctamente todos los scripts, se utilizo el entorno virtual 'venvTP2' con todos los paquetes 
%% presentados arriba

%% Para cargar la biblioteca libz.so.1, tambien es necesario instalar bibliotecas libz1:i386 y libc6:i386. 
%% Para poder hacerlo, es necesario habilitar que el sistema pueda trabajar con arquitectura de 32 bits:

sudo dpkg --add-architecture i386 % habilita arquitectura de 32 bits
sudo apt update
sudo apt install libz1:i386 libc6:i386 % instala las bibliotecas necesarias

%% Para el profiling en Python se comparo usando snakeviz y el modulo cProfile, 
%% los ejecutables main.py y main_asm.py 
%% -> Generando con cProfile los archivos profile_main.prof y profile_main_asm.prof respectivamente
%% Luego, con snakeviz se genera el archivo profile_main.html y profile_main_asm.html, los cuales no se 
%% guarda, pero se abren en internet y permiten una comparacion directa de lo que son los tiempos que tarda
%% cada funcion en ejecutarse, y el tiempo total de cada uno de los scripts.

%% PD: Todavia no se como medir de forma aislada las funciones que nos interesan

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% PROFILING CON C
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% OPCION DE MEDICION DIRECTA USANDO LA FUNCION CLOCK()

%% Se crea un nuevo prof_main_med_Clock.c para poder modificar main.c para realizar el profiling.
%% Se crea un nuevo prof_main.s para poder modificar main.s para realizar el profiling. 
%% -> main.s daba un error de compatibilidad con gcc, por lo que se tradujo de NASM a GAS
%% Se crea el archivo ensamblador .o para 32 bits:

gcc -m32 -c prof_main.s -o ftoi_add1_32bits.o

%% se compila de la siguiente manera:

gcc -m32 prof_main_med_Clock.c ftoi_add1_32bits.o -o prof_main_med_Clock

%% Enlazando el archivo ftoi_add1_32bits.o, y generando el ejecutable prof_main_med_Clock
%% Luego, se ejecuta el ejecutable prof_main_med_Clock:

./prof_main_med_Clock 

%% Arrojando el resultado de la medicion por codigo de los tiempos de ejecucion de cada funcion:

"
Tiempo de funcion con C: 0.000003 segundos
Tiempo de funcion con ASM: 0.000001 segundos
"

%% Notese que esta medicion no es exacta y varia entre iteraciones, 
%% Edit: Incluso luego de cambiar el tipo de variable de double a long double

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% OPCION DE MEDICION USANDO GPROF

%% Se crea un nuevo prof_main_med_gprof.c para poder modificar main.c para realizar el profiling.
%% -> Se crea una funcion main simplificada, que llame iteradas veces (10.000.000 de veces) a cada funcion, debido a que
%% son funciones muy rapidas
%% Luego, compilar el programa con la opción -pg, que habilita la generación de datos de profiling, y -O0,
para que no optimice el código, evitando posible simplicaciones:

gcc -m32 -pg -O0 prof_main_med_gprof.c ftoi_add1_32bits.o -o prof_main_med_gprof

%% Luego, se ejecuta el ejecutable prof_main_med_gprof:

./prof_main_med_gprof

%% Generando el archivo 'gmon.out', que contiene los datos de profiling.
%% Para visualizar los datos de profiling, se utiliza el comando gprof y se crea un archivo de texto:

gprof prof_main_med_gprof gmon.out > gprof_output.txt

%% En el archivo de texto gprof_output.txt, se puede observar el tiempo de ejecución de cada función.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Lo proximo seria:
%% - crear una direccion web local con Flask y comparar los valores de profiling obtenidos
%% - Es necesario hacer un profiling de memoria?